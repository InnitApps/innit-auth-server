{
  "name": "modinha-redis",
  "version": "0.0.6",
  "description": "Redis persistence mixins for Modinha models",
  "main": "lib/RedisDocument.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "grunt-mocha-cov": "0.0.7",
    "grunt-release": "~0.6.0",
    "grunt-contrib-watch": "~0.5.3",
    "grunt": "~0.4.1",
    "coffee-script": "~1.6.3",
    "Faker": "~0.5.11",
    "chai": "~1.8.1",
    "sinon": "~1.7.3",
    "sinon-chai": "~2.4.0",
    "modinha": "0.0.20"
  },
  "dependencies": {
    "async": "~0.2.9",
    "redis": "~0.9.0"
  },
  "readme": "The RedisDocument mixin for [Modinha](https://github.com/christiansmith/Modinha) defines a collection of persistence methods that map cleanly between HTTP semantics and Redis data structures.\n\n### Usage\n\nSuppose we've defined an Account model with Modinha like so:\n\n```javascript\nvar Modinha = require('modinha')\n  , RedisDocument = require('modinha-redis').RedisDocument\n\nvar Account = Modinha.define('accounts', {\n  email: { type: 'string', required: true, unique: true },\n  role:  { type: 'string', secondary: true, enum: ['admin', 'editor', 'author'] },\n  hash:  { type: 'string', private: true }\n});\n\nAccount.extend(RedisDocument);\n```\n\nRedisDocument will add the following persistence methods to the Account document.\n\n```\nHTTP                     MODEL METHOD\n\nGET    /accounts         Account.list(options, callback)\nGET    /accounts/id      Account.get(ids, options, callback)\nPOST   /accounts         Account.insert(data, options, callback)\nPUT    /accounts/id      Account.replace(id, data, options, callback)\nPATCH  /accounts/id      Account.patch(id, data, options, callback)\nDELETE /accounts/id      Account.delete(id, callback)\n```\n\nExtending Account with RedisDocument will also define the following properties on Account.schema:\n\n```javascript\n_id:      { type: 'string', required: true, default: Model.defaults.uuid },\ncreated:  { type: 'number', order: true, default: Model.defaults.timestamp },\nmodified: { type: 'number', order: true, default: Model.defaults.timestamp }\n```\n\nSince we defined `unique` and `secondary` properties on email and role, respectively, the mixin will also generate property specific methods for those indexes.\n\n```javascript\nAccount.getByEmail(email, callback)\nAccount.listByRole(role, callback)\n```\n\n### More about indexing\n\nWe can index in a variety of ways with Redis hashes and sorted sets. For example, we could explicitly define our unique email index like so:\n\n```javascript\nAccount.defineIndex({\n  type:  'hash',\n  key:   'accounts:email',\n  field: 'email',\n  value: '_id'\n});\n```\n\nThis tells the model to store an account's `_id` property in a hash named `accounts:email` with email as the field name. Because this is a very common use of the hash type index, the mixin also provides a helper method for defining unique indices:\n\n```javascript\nAccount.indexUnique('email');\n```\n\nThis is equivalent to adding `unique: true` to the property definition in our schema.\n\nSorted set indices get a little more interesting. We have a great deal of flexibility in how we can index our models. For example, suppose we have a `Video` model that has a `category` property and a `likes` property. We want to retrieve a list of videos for a specific category, sorted by the number of likes.\n\n```javascript\nVideo.defineIndex({\n  type:   'sorted',\n  key:    ['videos:#:$', 'category', 'category'],\n  score:  'likes',\n  member: '_id'\n});\n```\n\nWhen we index the following instance...\n\n```javascript\n{\n  _id: 'r4nd0m',\n  name: 'Awesome Presentation',\n  url: 'https://youtube.com/wh4t3v3r'\n  category: 'conferences',\n  likes: 777\n}\n```\n\n... the object's `_id` will be added to a sorted set in Redis called `videos:category:conferences`, with a score of 777. Notice the `key` property of the index definition: `['videos:#:$', 'category', 'category']`. The first element of this array is a template for a key name. In the template, the placeholders `#` and `$` will be replaced in order according to the remaining elements of the array. `#` will be replaced literally with element and `$` will be used to access a property on the object being indexed.\n\nLike the hash-type index, there are a few very common indexing patterns for sorted sets. The mixin provides higher level methods for defining these, and in some cases, they can be created as part of a schema definition. Some examples:\n\n```javascript\nModel.indexSecondary(propertyName, [score]);\nVideo.indexSecondary('category', 'likes');                     // Same as previous example\n\n\nModel.indexReference(propertyName, ReferencedModel, [score]);\nComment.indexReference('videoId', Video);                      // multi.zadd('videos:ID:comments', comment.created, comment._id);\n\n\nModel.indexOrder(propertyName);\nComment.indexOrder('likes');\n\n\n// video schema\n{\n  name:     { type: 'string', unique: true },\n  url:      { type: 'string', unique: true },\n  category: { type: 'string', enum: ['tutorial', 'presentation'], secondary: true },\n  likes:    { type: 'string', order: true }\n}\n```\n\n\nUnique values are enforced by the `insert`, `replace`, and `patch` methods. If you write custom methods, you can use `Account.enforceUnique(callback)` (for example) to generate a UniqueValueError.\n\nThe default timestamp methods define an ordered index for created and modified. `Account.list(options, callback)` uses the `accounts:created` index by default to deliver reverse chronological account listings.\n\n\n",
  "readmeFilename": "README.md",
  "_id": "modinha-redis@0.0.6",
  "dist": {
    "shasum": "0e92632788626d03def3e129c29036623c885301"
  },
  "_from": "modinha-redis@0.0.6",
  "_resolved": "https://registry.npmjs.org/modinha-redis/-/modinha-redis-0.0.6.tgz"
}
